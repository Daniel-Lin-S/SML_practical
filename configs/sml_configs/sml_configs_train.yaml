# naive_bayes:

# knn:
#   knn__n_neighbors: [3, 5, 7, 10, 15]

# lda:
#   lda__solver: ['eigen']
#   lda__shrinkage: [0.0, 0.001, 0.01, 0.1, 1.0]

# qda:
#   qda__reg_param: [0.0, 0.001, 0.01, 0.1, 1.0]
# logistic_regression:
#   logistic_regression__C: [1] # regularisation strength
#   logistic_regression__penalty: ['l2']
#   logistic_regression__solver: ['lbfgs']  # solver for optimisation


mlp:
  mlp__module__hidden_dims: [[384, 64], [384, 32], [256, 64], [256, 32], [64, 64], [64, 32]]
  mlp__module__dropout: [0.2, 0.5]
  # mlp__activation: ['relu']

# xgboost_rf:
#   # learning_rate: [0.1]
#   # subsample: [0.5]
#   # colsample_bynode: [0.2]
#   xgboost_rf__learning_rate: [0.01] # step size shrinkage used in each boosting iteration
#   xgboost_rf__n_estimators: [100, 200] # number of trees
#   xgboost_rf__max_depth: [3, 5] # max tree depth
#   xgboost_rf__subsample: [0.1, 0.3, 0.5] # fraction of samples used for fitting each tree
#   xgboost_rf__colsample_bynode: [0.1, 0.3, 0.5] # fraction of features used for fitting each tree
  # xgboost_rf__gamma: [0, 0.1, 0.2] # Minimum loss reduction required to make a further partition on a leaf node of the tree.

# random_forest:
#   random_forest__n_estimators: [100, 200, 300] # number of trees in the forest
#   random_forest__max_depth: [None, 5, 10] # maximum depth of the tree
#   random_forest__min_samples_split: [2, 5, 10] # minimum number of samples required to split an internal node
#   random_forest__min_samples_leaf: [1, 2, 4] # minimum number of samples required to be at a leaf node
#   random_forest__max_features: ['auto', 'sqrt'] # number of features to consider when looking for the best split




# c_svm:
#   # C: [0.001, 0.01, 0.1, 1] # regularisation strength
#   c_svm__C: [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 5.0]
#   # kernel: ['linear', 'poly', 'rbf', 'sigmoid'] # kernel function
#   c_svm__kernel: ['rbf']
#   # degree: [2, 3, 4, 5, 6] # degree of the polynomial kernel function
#   # c_svm__degree: [3]
#   c_svm__gamma: ['scale'] # kernel coefficient for 'rbf', 'poly', and 'sigmoid'

# c_svm:
#   # C: [0.001, 0.01, 0.1, 1] # regularisation strength
#   c_svm__C: [2.0]
#   # kernel: ['linear', 'poly', 'rbf', 'sigmoid'] # kernel function
#   c_svm__kernel: ['rbf']

  
